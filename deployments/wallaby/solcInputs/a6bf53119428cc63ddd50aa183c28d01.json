{
  "language": "Solidity",
  "sources": {
    "contracts/ESignature.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nenum AgreementStatus {\n  PENDING,\n  COMPLETE,\n  APPROVED,\n  REJECTED\n}\n\nstruct Profile {\n  uint32 totalAgreements;\n  uint32 totalSignatures;\n}\n\nstruct SignatureConstraint {\n  string identifier;\n  address signer;\n  bool used;\n}\n\nstruct Agreement {\n  address owner;\n  AgreementStatus status;\n  uint32 index;\n  string identifier;\n  string cid;\n  string encryptedCid;\n  uint8 signedPackets;\n  uint8 totalPackets;\n  SignatureConstraint[] constraints;\n}\n\nstruct ESignaturePacket {\n  address agreement_owner;\n  uint32 agreement_index;\n  uint32 index;\n  string identifier;\n  string encryptedCid;\n  address signer;\n}\n\ncontract ESignature {\n  mapping(address => Profile) profiles;\n  mapping(address => mapping(uint32 => Agreement)) agreements;\n  mapping(address => mapping(uint32 => ESignaturePacket)) packets;\n\n  function createAgreement(\n    string calldata identifier,\n    string calldata cid,\n    string calldata encryptedCid,\n    SignatureConstraint[] memory constraints\n  ) public returns (uint32) {\n    Profile storage profile = profiles[tx.origin];\n    Agreement storage agreement = agreements[tx.origin][\n      profile.totalAgreements\n    ];\n\n    agreement.owner = tx.origin;\n    agreement.status = AgreementStatus.PENDING;\n    agreement.index = profile.totalAgreements;\n    agreement.identifier = identifier;\n    agreement.cid = cid;\n    agreement.encryptedCid = encryptedCid;\n    agreement.signedPackets = 0;\n    agreement.totalPackets = uint8(constraints.length);\n\n    for (uint i = 0; i < constraints.length; i++) {\n      agreement.constraints.push(constraints[i]);\n    }\n\n    return profile.totalAgreements++;\n  }\n\n  function getAgreements(\n    address owner,\n    uint32 offset\n  ) public view returns (Agreement[] memory) {\n    Profile memory profile = profiles[owner];\n\n    uint index = 0;\n    uint remaining = profile.totalAgreements - offset;\n    Agreement[] memory ags = new Agreement[](remaining > 10 ? 10 : remaining);\n\n    for (uint32 i = offset; i < profile.totalAgreements; i++) {\n      ags[index++] = agreements[owner][i];\n    }\n\n    return ags;\n  }\n\n  function sign(\n    address agreement_owner,\n    uint32 agreement_index,\n    string calldata identifier,\n    string calldata encryptedCid\n  ) public returns (uint32) {\n    Agreement storage agreement = agreements[agreement_owner][agreement_index];\n    require(agreement.owner == agreement_owner, \"Invalid agreement\");\n    require(\n      agreement.status == AgreementStatus.PENDING,\n      \"Agreement is not PENDING \"\n    );\n\n    SignatureConstraint storage constraint;\n    bool found = false;\n    for (uint i = 0; i < agreement.constraints.length; i++) {\n      if (\n        keccak256(abi.encodePacked(agreement.constraints[i].identifier)) ==\n        keccak256(abi.encodePacked(identifier))\n      ) {\n        found = true;\n        constraint = agreement.constraints[i];\n        require(\n          constraint.signer == tx.origin || constraint.signer == address(0),\n          \"Mismatched signer\"\n        );\n        constraint.signer = tx.origin;\n        constraint.used = true;\n        break;\n      }\n    }\n\n    require(found, \"Missing signature constraint\");\n\n    Profile storage profile = profiles[tx.origin];\n\n    packets[tx.origin][profile.totalSignatures] = ESignaturePacket({\n      agreement_owner: agreement.owner,\n      agreement_index: agreement.index,\n      index: profile.totalSignatures,\n      identifier: identifier,\n      encryptedCid: encryptedCid,\n      signer: tx.origin\n    });\n\n    agreement.signedPackets++;\n    if (agreement.signedPackets == agreement.totalPackets) {\n      agreement.status = AgreementStatus.COMPLETE;\n    }\n\n    return profile.totalSignatures++;\n  }\n\n  function getSignatures(\n    address owner,\n    uint32 offset\n  ) public view returns (ESignaturePacket[] memory) {\n    Profile memory profile = profiles[owner];\n\n    uint index = 0;\n    uint remaining = profile.totalSignatures - offset;\n    ESignaturePacket[] memory sigs = new ESignaturePacket[](\n      remaining > 10 ? 10 : remaining\n    );\n\n    for (uint32 i = offset; i < profile.totalAgreements; i++) {\n      sigs[index++] = packets[owner][i];\n    }\n\n    return sigs;\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}